<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_stand</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Define variables

//Constant
grav = 1;
MOVE_SPD = 2;       //walking speed
VSP_MAX = 8;       //maximum falling speed
JUMP_SPD = 10;      //initial jumping vsp
JUMP_DECEL = 1;     //deceleration after jumping
FEET_OFFSET = bbox_bottom - bbox_top;   //feet offset from center (should be 30) 
dir = 1;        

//State constants
STANDING=0;
WALKING=1;
JUMPING=2;
FALLING=3;

//variable
hsp = 0;
vsp = 0;
state = STANDING;
isattack = false;
ishurt = false;
invincible = false;

//drawing variables
color = c_white
alpha = 1;

show_debug_message(string(sprite_xoffset));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Restore to Normal State (from Hurt state)
ishurt = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="9">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Stop Invisibility
invincible = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_player</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite control

if(hsp!=0){
dir = sign(hsp);
}

if(isattack){
sprite_index = spr_player_attack;
image_speed = 0.5;
}else if(!ishurt){

if(state &gt;= 2){
    sprite_index = spr_player_jump;
    image_xscale = dir;
}else{
    if(hsp==0){
        sprite_index = spr_player_stand;
        image_index  = 0;
        image_speed = 0;
    }else{
        sprite_index = spr_player_walk;
        image_speed = 0.25;
        image_xscale = dir;
    }
}

}

if(ishurt){
     sprite_index = spr_player_hurt;
}

if(invincible){
alpha = 0.5;
}else{
alpha = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input Control

//------------------------------
//      INPUT CONTROL
//------------------------------

//Get the player's input
key_right = keyboard_check(vk_right);   //1 if pressing right, 0 otherwise
key_left = -keyboard_check(vk_left);    //-1 if pressing left, 0 otherwise
key_jump = keyboard_check_pressed(vk_space);

//key_left=-1;
//Horizontal movement control
if(!isattack){
move = key_left+key_right;  //if pressing both right and left, movement cancels out
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement, gravity, jump, state control

//Horizontal movement control
if(!isattack&amp;&amp;!ishurt){
hsp = move*MOVE_SPD;
}

//Gravity control
vsp = min(vsp+grav,VSP_MAX);


//Standing &amp; Jump Control
if (collision_rectangle(bbox_left, bbox_bottom, bbox_right, bbox_bottom+1, obj_solid, false, true) or position_meeting(x,y+FEET_OFFSET+1,obj_slope)) //if standing on ground
{
    state = STANDING;
    vsp = 0;
    
    if(key_jump&amp;&amp;!isattack&amp;&amp;!ishurt) {
        state = JUMPING;
        vsp = -JUMP_SPD;
    }
}
if(state==JUMPING and vsp &lt; 0 and not keyboard_check(vk_space)){
    vsp = round(vsp/JUMP_DECEL);
}

//Player State Control
if(hsp!=0 &amp;&amp; state==STANDING){
    state = WALKING;
}
if(vsp&gt;0){
    state = FALLING;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Solid Collision + Slope Cllision

//horizontal collision
if(hsp != 0 and place_meeting(x+hsp,y,obj_solid)){      //if moving and colliding with solid in direction moving
        while(!place_meeting(x+sign(hsp),y,obj_solid)){ //move in 1 pixel until contact
            
            x += sign(hsp);
        }
        if(sign(image_xscale) != sign(hsp)) x -= sign(hsp);
        hsp = 0;
    
    
}


//vertical collision
if(vsp != 0 and place_meeting(x,y+vsp,obj_solid)){      //if moving and colliding with solid in direction moving
    if(vsp &lt; 0 and !place_meeting(x+2,y+vsp,obj_solid)){        //snap to wall when falling/rising very near to vertical walls
        x += 2;
    } else if(vsp &lt; 0 and !place_meeting(x-2,y+vsp,obj_solid)){
        x -= 2;
    } else {
        while(!place_meeting(x,y+sign(vsp),obj_solid)){ //move in 1 pixel until contact
            y += sign(vsp);
        }
        vsp = 0;
    }
          

}


//Diagonal
if(hsp!=0 and vsp!=0 and place_meeting(x+hsp, y+vsp, obj_solid)){   //if moving and colliding with solid in direction moving
    
    while(!place_meeting(x+sign(hsp),y,obj_solid)){         //move in 1 pixel until contact
        x += sign(hsp);
        y += sign(vsp);
    }
    
    while(place_meeting(x, y + sign(vsp), obj_solid))       //snap to wall when moving diagonally when falling/rising very near to vertical walls
    {
        x -= sign(hsp);
    }
    hsp = 0;
}


//--------------------------------
//  SLOPE COLLISION
//--------------------------------
//  All slope objects are inherited from obj_slope which is sued to test collision

//slope vertical collision
if(vsp!= 0 and position_meeting(x,y+FEET_OFFSET+vsp,obj_slope)){      //if moving and colliding with slope in direction moving
     while(!position_meeting(x,y+FEET_OFFSET+sign(vsp),obj_slope)){   //move in 1 pixel until contact
         y += sign(vsp);
     }
     vsp = 0;
}

//walking on slope collision
//First, check if player is going up slope or not
//This is done by checking that next position horizontally is still on slope, if yes it means player is going up on the slope
slope_up_inst = instance_position(floor(x+hsp),y+FEET_OFFSET,obj_slope);  //check if next position is still on slope
if (slope_up_inst != noone){    //if yes it will be that slope object id
    
    if(slope_up_inst.SLOPE_RATIO == 0){     //if it's "obj_slope_end" then it will always push player up to its top
        rel_x = sprite_get_height(slope_up_inst.sprite_index);         
    } else {
        //calculate relative x position of player from the slope x (very left)
        rel_x = floor(x+hsp) - slope_up_inst.x;     
        if(slope_up_inst.SLOPE_RATIO &lt; 0){  //if opposite slope direction invert the relative value
            rel_x = sprite_get_width(slope_up_inst.sprite_index) - 1 - rel_x;
        }
    }
    //show_debug_message(string(slope_up_inst)+" "+string(rel_x));
    //set player at position relative to that slope y position using rel_x as a offset
    player_y_above_offset =  abs(FEET_OFFSET+1 - sprite_get_height(slope_up_inst.sprite_index));
    newy = slope_up_inst.y - player_y_above_offset - rel_x;
    
    y = floor(newy);
    
} else {
    //If not going up, check if he is going down on slope or not
    //Check first if player is standing on slope, then check if next position player would be if he is going down on slope is still on slope
    standing_slope = instance_position(x,y+FEET_OFFSET+1,obj_slope);  //check if standing on slope
    if(standing_slope != noone){
        slope_down_inst = instance_position(floor(x+hsp),floor(y+FEET_OFFSET+abs(hsp)+1),obj_slope);  //check if still on slope at position he would be if he goes down on slope
        if(slope_down_inst != noone){       //if yes it will be that slope object id
            
            if(slope_down_inst.SLOPE_RATIO == 0){  //if it's "obj_slope_end" then it will always push player up to its top
                rel_x = sprite_get_height(slope_down_inst.sprite_index);           
            } else {
                //calculate relative x position of player from the slope x (very left)
                rel_x = floor(x+hsp) - slope_down_inst.x;
                if(slope_down_inst.SLOPE_RATIO &lt; 0){
                    rel_x = sprite_get_width(slope_down_inst.sprite_index) - 1 - rel_x;   //if opposite slope direction invert the relative value
                }
            }
            
            //show_debug_message(string(slope_down_inst)+" "+string(rel_x));
            //set player at position relative to that slope y position using rel_x as a offset
            player_y_above_offset =  abs(FEET_OFFSET+1 - sprite_get_height(slope_down_inst.sprite_index));
            newy = slope_down_inst.y - player_y_above_offset - rel_x;
            y = floor(newy);
        }
    }
    
}

//update player to his next position
x = floor(x+hsp);
y = floor(y+vsp);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Called only when hurted by something

if(!ishurt&amp;&amp;!invincible){
global.playerHp-=1;
invincible=true;
ishurt = true;
hsp = -3*dir;
vsp = -5;
y=y-3;
alarm[9]=15; //remove invincibility
alarm[10]=10;//return to normal state
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(sprite_index=spr_player_attack){
sprite_index=spr_player_stand;
isattack=false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!instance_exists(obj_camera)){
instance_create(0,0,obj_camera)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite_ext(sprite_index, image_index, x, y, image_xscale, 1, 0, color, alpha );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="88">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!isattack){
instance_create(x-sprite_width*(dir-1)/2,y+8,obj_pl_meleeatk);
isattack=true;
image_index=  0;
hsp=0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
